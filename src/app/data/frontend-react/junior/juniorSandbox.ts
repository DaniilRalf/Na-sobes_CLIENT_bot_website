const JuniorSandbox = [

  // {
  //   number: 1,
  //   question: 'Что такое Virtual DOM?',
  //   answer: {"data":[{"paragraph": "Виртуальный DOM (VDOM) — это подход для при котором \"виртуальное\" представление пользовательского интерфейса хранится в памяти. И этот виртуальный DOM синхронизируется с \"настоящим\" DOM. В React для этого используется библиотеки (react-dom). Сам этот процесс называется согласованием (reconciliation)."},
  //       {"paragraph": "Также React использует внутренние объекты, называемые \"волокнами\" (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации \"виртуального DOM\" в React."},
  //       {"paragraph": "Fiber - это JS объект который содержит информацию о компоненте его входные параметры и результат."}]}
  // },
  // {
  //   number: 2,
  //   question: 'Что такое JSX?',
  //   answer: {"data":[{"paragraph": "JSX - это дополнение к синтаксису JS, который позволяет писать HTML в React компонентах. JSX — синтаксический сахар для функции React.createElement(component, props, ...children)."},
  //       {"paragraph": "Этот JSX-код:"},
  //       {"code": "return <Component />"},
  //       {"paragraph": "…конвертируется в:"},
  //       {"code": "return React.createElement(SomeComponent, {a: 42, b: \"testing\"}, \"Text Here\")"},
  //       {"paragraph": "…и результатом будет объект:"},
  //       {"code": " {\n  type: SomeComponent,\n  props: {a: 42, b: \"testing\"},\n  children: [\"Text Here\"]\n }"},
  //       {"paragraph": "За правильный парсинг и дальнейшую обработку отвечает babel."},
  //       {"paragraph": "Если название типа элемента начинается с маленькой буквы, он ссылается на встроенный компонент, например, <div> или <span>, что в результате приведет к тому, что в React.createElement будет передана строка 'div' или 'span'. Типы, начинающиеся с заглавной буквы, такие как <SomeComponent />, компилируются в React.createElement(SomeComponent) и соответствуют компоненту, который был объявлен или импортирован в JavaScript-файле."},
  //       {"paragraph": "React можно использовать без JSX. Это особенно удобно, когда нет необходимости настраивать транспиляцию в процессе сборки."}]}
  // },
  // {
  //   number: 3,
  //   question: 'В чем разница memo и useMemo?',
  //   answer: {"data":[{"paragraph": "memo — это компонент высшего порядка."},
  //       {"paragraph": "Он нужен для повышения производительности и подходит для случаев, когда компонент рендерит одинаковый результат при одних и тех же значениях пропсов. В этом случае результат будет мемоизирован. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга."},
  //       {"paragraph": "При использовании memo пропсы по умолчанию сравниваются поверхностно. Можно передать свою функцию сравнения в качестве второго аргумента (если нужно контролировать сравнение)."},
  //       {"paragraph": "useMemo - это хук, который возвращает мемоизированное значение функции, которая делает долгие вычисления. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось."}]}
  // },
  // {
  //   number: 4,
  //   question: 'Что такое Pure Components (Чистые компоненты)?',
  //   answer: {"data":[{"paragraph": "Компонент является чистым, если он гарантированно возвращает один и тот же результат при одинаковых пропсах и состоянии"},
  //       {"paragraph": "Для чего нужны чистые компоненты и чем они лучше? Чистые компоненты имеют улучшенную производительность за счет поверхностного сравнения пропсов и состояния."},
  //       {"paragraph": "Для классовых компонентов"},
  //       {"paragraph": "shouldComponentUpdate - необязательный метод жизненного цикла. Если этот метод возвращает false, React пропустит рендеринг компонента. Он может содержать любую логику сравнения пропосв и состояния с их предыдущими значениями."},
  //       {"paragraph": "React.PureComponent может быть использован вместо Component + shouldComponentUpdate."},
  //       {"paragraph": "Для функциональных и для классовых компонентов"},
  //       {"paragraph": "React.memo() - компонент высшего порядка. В качестве первого аргумента получает компонент и возвращает новый компонент. По умолчанию сравнение происходит поверхностное. Однако, вторым аргументом можно передать свой кастомный компаратор - функцию сравнения (arePropsEqual())"},
  //       {"paragraph": "Поверхностное сравнение происходит при помощи оператора ===."}]}
  // },
  // {
  //   number: 5,
  //   question: 'Особенности использования Context API + useReducer вместо Redux?',
  //   answer: {"data":[{"paragraph": "Безусловно, useReducer() позволяет обрабатывать обновления состояния с помощью редьюсеров без необходимости использования хранилища Redux, а useContext() позволяет передавать значения через дерево React без необходимости передавать их вниз через каждый уровень компонентов в качестве пропсов."},
  //       {"paragraph": "Однако, как и в случае с самим Context API, хук useReducer() не имеет дополнительных возможностей, которые предоставляет Redux. Нет ни отладки с перемещением во времени, ни middleware, ни специальных DevTools Extension, позволяющего увидеть, как состояние менялось с течением времени."}]}
  // },

  {
    number: 6,
    question: 'asdasdasd',
    answer: {"data":[
        {"paragraph": ""},
        {"paragraph": ""},
        {"code": ""},
        {"paragraph": ""}
      ]}
  },

]
